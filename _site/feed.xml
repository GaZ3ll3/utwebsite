<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome to Yimin's Homepage</title>
    <description>Academic homepage of Yimin</description>
    <link>http://www.ma.utexas.edu/users/yzhong</link>
    <atom:link href="http://www.ma.utexas.edu/users/yzhong/feed.xml" rel="self" type="application/rss+xml" />
    
      <item>
        <title>Quadrature Rule</title>
        <description>&lt;p&gt;For many PDE problems, they have some integral equation representation form too. I once mentioned whether it is good or not to put problem into integral form or not. For a lot of times, I think explicit form of something like Green&amp;#39;s function is necessary for such a solution
$$u = \int G(x, y)f(y)$$
over surface or volume.&lt;/p&gt;
</description>
        <pubDate>Wed, 26 Apr 2017 00:00:00 -0500</pubDate>
        <link>http://www.ma.utexas.edu/users/yzhong/2017/04/26/quadrature-rule/</link>
        <guid isPermaLink="true">http://www.ma.utexas.edu/users/yzhong/2017/04/26/quadrature-rule/</guid>
      </item>
    
      <item>
        <title>PAT IN 3D</title>
        <description>&lt;p&gt;It is quite challenging to numerically implement PAT in 3D. Especially for very high resolution imaging reconstruction.&lt;/p&gt;

&lt;p&gt;Even for solving the photon diffusion part is nontrivial on a grid of &lt;code&gt;512x512x512&lt;/code&gt;. To stably get recovery in diffusion coefficient, we need to solve the multi-source problem to at least third order, which means &lt;code&gt;H&lt;/code&gt; must be non-vanishing and accurate up to error of &lt;code&gt;h^3&lt;/code&gt;. If we are solving the equation with finite element forward solver, it is not cheap at all. The system will involve millions of dofs, only supercomputer or cluster could help.&lt;/p&gt;

&lt;p&gt;On our laptop, it is still unclear that whether a mesh larger than &lt;code&gt;64x64x64&lt;/code&gt; could work under second order FE smoothly. Down-sampling from the data, it is still reasonable to get some reconstruction up to some resolution.&lt;/p&gt;

&lt;p&gt;All we need is a fast forward solver, with parallelism, an option will be &lt;code&gt;PETSc&lt;/code&gt;. The detailed implementation could be any, &lt;code&gt;fenics&lt;/code&gt; is well-built for finite element solvers on top of &lt;code&gt;PETSc&lt;/code&gt;, could run in parallel over many cores.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MATLAB&lt;/code&gt; will be a tough choice to handle too large system, it does not provide good support on MPI either. &lt;code&gt;Julia&lt;/code&gt; has some good libraries and graph tools, but not as many as &lt;code&gt;Python&lt;/code&gt; currently does.&lt;/p&gt;

&lt;p&gt;An interface prototype is needed then. [TO BE CONTINUED]&lt;/p&gt;
</description>
        <pubDate>Mon, 24 Apr 2017 00:00:00 -0500</pubDate>
        <link>http://www.ma.utexas.edu/users/yzhong/2017/04/24/PAT-in-3D/</link>
        <guid isPermaLink="true">http://www.ma.utexas.edu/users/yzhong/2017/04/24/PAT-in-3D/</guid>
      </item>
    
      <item>
        <title>Coding with Sparse Matrix</title>
        <description>&lt;p&gt;The difficulty in handling sparse matrix in coding is always underestimated. In &lt;code&gt;MATLAB&lt;/code&gt;, there is nothing extra to do with sparse matrix, because the software has taken care of it. For other languages like &lt;code&gt;C++&lt;/code&gt;, a fast and robust sparse matrix library is quite necessary for radiative transport equation, since each ray-tracing forms a extremely sparse matrix. And it will involve intense additions for sparse matrices.&lt;/p&gt;

&lt;p&gt;There are several popular libraries for sparse matrix operations. &lt;code&gt;csparse&lt;/code&gt; is one of it, using traditional &lt;code&gt;CSC&lt;/code&gt; or &lt;code&gt;CSR&lt;/code&gt; format to store the matrix.&lt;/p&gt;

&lt;p&gt;TO BE CONTINUED.&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Jan 2017 00:00:00 -0600</pubDate>
        <link>http://www.ma.utexas.edu/users/yzhong/2017/01/03/coding-with-sparse-matrix/</link>
        <guid isPermaLink="true">http://www.ma.utexas.edu/users/yzhong/2017/01/03/coding-with-sparse-matrix/</guid>
      </item>
    
      <item>
        <title>PML for 3D Wave Equation</title>
        <description>&lt;p&gt;In previous post, the wave equation in 2D, with PML for absorption boundary condition. The system is augmented to 4 unknown variables. And in 3D case, regardless of possible issues from PML, the system should involve more unknowns for additional dimension, however, it is actually more than that. It will bring an $s^{-1}$ term, representing an temporal integral.&lt;/p&gt;

&lt;p&gt;By Laplace transform (or Fourier transform) to frequency domain, the equation is simply as ($s$ is complex)&lt;/p&gt;

&lt;p&gt;$$s^2 u  = c^2 \Delta u$$&lt;/p&gt;

&lt;p&gt;By changing coordinate for each axis (e.g. $x, y, z$),
$$\tilde{x} = x + \displaystyle\int_0^x \sigma_x(\xi) d\xi$$&lt;/p&gt;

&lt;p&gt;we will arrive at a new system&lt;/p&gt;

&lt;p&gt;$$(s^2 + s(\sigma_x + \sigma_y + \sigma_z) + (\sigma_x\sigma_y + \sigma_y\sigma_z + \sigma_z \sigma_x) + \sigma_x\sigma_y\sigma_z s^{-1}) u = c^2 \Delta u + \nabla\cdot \Phi$$&lt;/p&gt;

&lt;p&gt;where $\Phi = (\phi^1, \phi^2, \phi^3)$ are auxiliary functions, inverting $s$ to $\partial_t$, we put the equation back to time domain,&lt;/p&gt;

&lt;p&gt;$$u_{tt} + p_1 u_t + p_2u + p_3 U = c^2 \Delta u + \nabla\cdot \Phi$$&lt;/p&gt;

&lt;p&gt;$$\Phi_t + \Sigma \Phi = c^2 (p_1 \mathbb{I} - \Sigma)\nabla u + \Gamma \nabla U$$&lt;/p&gt;

&lt;p&gt;$$U_t = u$$&lt;/p&gt;

&lt;p&gt;where $\Sigma = \mathrm{diag}(\sigma_x, \sigma_y, \sigma_z)$ and $\Gamma = \mathrm{diag}(\sigma_y\sigma_z, \sigma_z\sigma_x, \sigma_x\sigma_y)$. $p_1= \mathrm{Tr}(\Sigma)$, $p_2 = \mathrm{Tr}(\Gamma)$, $p_3 = \mathrm{det}(\Sigma)$.&lt;/p&gt;

&lt;p&gt;There are 6 unknowns to solve : $Y = (u, u_t, \phi^1, \phi^2, \phi^3, U)$. The system&amp;#39;s initial condition is from wave equation, additional variables are initialized as zero.&lt;/p&gt;

&lt;p&gt;$$Y_t = L Y$$&lt;/p&gt;

&lt;p&gt;can be solved with various numerical methods, $L$ is a second order operator in spatial variables, thus we can use FDM, FEM, pseudo-spectral.&lt;/p&gt;

&lt;p&gt;Pseudo-spectral is slower in complexity, but it will involve less points, since it is more accurate on the derivatives. The system needs evaluation on $U_x, U_y, U_z, u_x, u_y, u_z, c^2\Delta u, \nabla\cdot \Phi$ respectively, which requires &lt;code&gt;fft&lt;/code&gt; for 5 times on $u, U, \Phi$ and &lt;code&gt;ifft&lt;/code&gt; for 8 times, each &lt;code&gt;fft/ifft&lt;/code&gt; in theory needs $15Nlog_2N$ in 3D, thus total flops are $195 N\log_2 N$ flops, for a grid as large as 200x200x200, the total flops will be &lt;code&gt;7E10&lt;/code&gt; or so. On a single core machine at effective frequency 2.0GHz, the time will be &lt;code&gt;30s&lt;/code&gt; for one evaluation! For multi-core (say quad-core) platform, it will require (maybe) &lt;code&gt;10s&lt;/code&gt; for one run, 1000 time-steps with forward Euler will be about 3h, multi-step methods like RK2, RK3, RK4, the time will be much longer.&lt;/p&gt;

&lt;p&gt;If precision is not important, using &lt;code&gt;single&lt;/code&gt; precision will cut the timing in half.&lt;/p&gt;
</description>
        <pubDate>Fri, 23 Dec 2016 00:00:00 -0600</pubDate>
        <link>http://www.ma.utexas.edu/users/yzhong/2016/12/23/PML-for-3D-wave-equation/</link>
        <guid isPermaLink="true">http://www.ma.utexas.edu/users/yzhong/2016/12/23/PML-for-3D-wave-equation/</guid>
      </item>
    
      <item>
        <title>Simplified Spherical Harmonics</title>
        <description>&lt;p&gt;Simplified spherical harmonics has been proposed decades ago, and it provides an approximation to ERT, by generalizing differential operator $dx$ to $\nabla$. The solution can be obtained by solving a diffusion equation system, instead of solving just one diffusion equation by assuming diffusive regime, $SP_n$ can make corrections to diffusion system by capturing more details/modes.&lt;/p&gt;

&lt;p&gt;One thing to notice is, $SP_n$ is still an approximation even $n\to \infty$, since it is not solving the actual equation.  Usually, the scattering behavior is described with phase function, and a common choice is Henyey-Greenstein phase function.&lt;/p&gt;

&lt;p&gt;$$p(\mu, g) = \frac{1 - g^2}{4\pi (1 + g^2 - 2g\mu)^{3/2}}$$&lt;/p&gt;

&lt;p&gt;where $\mu = \Omega&amp;#39;\cdot \Omega$ as the scattering angle. And&lt;/p&gt;

&lt;p&gt;$$p(\mu, g) = \sum_{n=0}^{\infty} \frac{2n+1}{4\pi} g^n P_n(\mu)$$&lt;/p&gt;

&lt;p&gt;One interesting thing is to compare the idea behind integral-based method with reduced phase, and simplified spherical harmonics. If we follow the idea of $SP_n$, consider the 1D model and generalize to finite domain, then it is straightforward, because we just take azimuth angle and ignore the polar angle, completely achieves the same complexity, but model is slightly changed.&lt;/p&gt;

&lt;p&gt;Under forward-peaking regime with large scattering, this is  reasonable though.&lt;/p&gt;
</description>
        <pubDate>Thu, 10 Nov 2016 00:00:00 -0600</pubDate>
        <link>http://www.ma.utexas.edu/users/yzhong/2016/11/10/simplified-spherical-harmonics/</link>
        <guid isPermaLink="true">http://www.ma.utexas.edu/users/yzhong/2016/11/10/simplified-spherical-harmonics/</guid>
      </item>
    
      <item>
        <title>Time domain RTE</title>
        <description>&lt;p&gt;The time dependent radiative transport equation is stated as
$$
\begin{equation}
\begin{aligned}
&amp;amp;\frac{1}{c}\frac{\partial u}{\partial t} + \hat{s}\cdot \nabla u = \sigma(B(\nu, T) - u)\\
&amp;amp;C_{\nu}\frac{\partial T}{\partial t} = \int_{S^{d-1}}\int_0^{\infty} \sigma(u - B(\nu, T)) d\nu d\hat{s}
\end{aligned}
\end{equation}
$$
which describes the interaction of material and radiation. where $u(x, t, \hat{s},\nu)$ is radiation intensity, $T = T(x,t)$ is material temperature. $\sigma = \sigma(x, \nu, T)$ is opacity thickness, $C_{\nu}$ is heat capacity.
$$B(\nu, T) = \frac{2h}{c^3}\frac{\nu^3}{\exp(h\nu/k T) - 1}$$&lt;/p&gt;

&lt;p&gt;by using approximation, the equation can be rewritten as an easier one,
$$
\begin{equation}
\begin{aligned}
&amp;amp;\frac{1}{c}\frac{\partial u}{\partial t} + \hat{s}\cdot \nabla u + \sigma u = \frac{\sigma b}{|S^{d-1}|} acT^4\\
&amp;amp;C_{\nu}\frac{\partial T}{\partial t} = \int_{S^{d-1}}\int_0^{\infty} \sigma d\nu \int_{S^{d-1}} u \hat{s} - \sigma_p acT^4
\end{aligned}
\end{equation}
$$&lt;/p&gt;

&lt;p&gt;where $b$ is average of $B$, $\sigma_p$ is average of $\sigma b$.&lt;/p&gt;

&lt;p&gt;There is a way to decouple the equations, by taking $t$ as another spatial variable. $z = (x, t)$, we have
$$
\tilde{s}\cdot \nabla_z u + \sigma(z, \nu) u = H(z, \nu)
$$&lt;/p&gt;

&lt;p&gt;which is quite easy to come up with a solution for $\phi = \int_{S^{d-1}} u$. And insert into temperature equation.&lt;/p&gt;

&lt;p&gt;$$C_{\nu}\frac{\partial T}{\partial t} = \int_0^{\infty}\sigma d\nu \int_{S^{d-1}}\int_0^{\tau^{-}(z,\tilde{s})} \exp(-\int_0^p\sigma(z-\mu\tilde{s})d\mu) H(z - p\tilde{s}) dp d\tilde{s} - \sigma_p ac T^4$$&lt;/p&gt;

&lt;p&gt;And solving this can apply some fast algorithm like &lt;code&gt;treecode&lt;/code&gt; or &lt;code&gt;FMM&lt;/code&gt; as we did before, forward Euler scheme will generate $O(\Delta x)$ error.&lt;/p&gt;
</description>
        <pubDate>Mon, 19 Sep 2016 00:00:00 -0500</pubDate>
        <link>http://www.ma.utexas.edu/users/yzhong/2016/09/19/time-domain-RTE/</link>
        <guid isPermaLink="true">http://www.ma.utexas.edu/users/yzhong/2016/09/19/time-domain-RTE/</guid>
      </item>
    
      <item>
        <title>Differential Equation VS. FMM</title>
        <description>&lt;p&gt;After a long time of thinking, I would say fast multiple method is not a good method for solving differential equation, though it is a great algorithm.&lt;/p&gt;

&lt;h4 id=&quot;toc_0&quot;&gt;interpolation vs. extrapolation&lt;/h4&gt;

&lt;p&gt;Finite difference method on a structured grid, approximating the differential operator using stencil, will generate a sparse system, which generally gives $\mathcal{O}(N)$ complexity, the constant depends on the wanted precision and order of equation.&lt;/p&gt;

&lt;p&gt;The error analysis usually gives $\mathcal{O}(h^s)$, decreasing w.r.t $h$ the grid size.&lt;/p&gt;

&lt;p&gt;FMM, in someway we can obtain the Green function, the solution is integral form, the error comes from two parts.&lt;/p&gt;

&lt;p&gt;The first is discretization, depending on $h$. The second is from FMM algorithm itself, depending on its parameters, could be arbitrarily small, but will be dominated by the first one easily, a good rule is to select parameters to be comparable to the discretization error.&lt;/p&gt;

&lt;p&gt;Well, the discretization error is terrible for FMM, to make the precision high enough, interpolation is very important, we need to import more points on the smallest resolution to get a high order quadrature rule, increasing the computing cost by a linear constant. The case is: this constant is as the same level as FDM (which uses extrapolation).&lt;/p&gt;

&lt;h4 id=&quot;toc_1&quot;&gt;when to use&lt;/h4&gt;

&lt;p&gt;I think, the only case to use FMM on equation, is only good on integral equation only, no explicit differential equation is available. Unless FMM can reduce a lot of computation cost, otherwise, there is no need to use.&lt;/p&gt;
</description>
        <pubDate>Sun, 04 Sep 2016 00:00:00 -0500</pubDate>
        <link>http://www.ma.utexas.edu/users/yzhong/2016/09/04/differential-equation-vs-fmm/</link>
        <guid isPermaLink="true">http://www.ma.utexas.edu/users/yzhong/2016/09/04/differential-equation-vs-fmm/</guid>
      </item>
    
      <item>
        <title>Thoughts on Fast Multipole III</title>
        <description>&lt;p&gt;Continue with last post. Consider the pseudo-differential elliptic operator $P = \sum_{|\alpha|\le 2m} c_{\alpha}(x) D^{\alpha}$, if we have $P u(x) = f(x)$, with Dirichlet boundary condition $u^{\alpha} = 0$ for $|\alpha|\le m-1$.&lt;/p&gt;

&lt;p&gt;$$\int_{\Omega}(P^{\ast}v(x, y))u(x) -  (Pu(x)) v(x, y) dx   = \sum_{\beta}\int_{\partial\Omega}\psi_{\beta}(x) v^{\beta}(x, y) dx$$&lt;/p&gt;

&lt;p&gt;Here consider Green function $P^{\ast}v(x, y) = \delta_y(x)$, which is $P v(y, x) = \delta_y(x)$. If we say $K(x, y)$ is Green function of $P$, then we have to replace $x$ and $y$ in $v$, thus $K(x, y) = v(y, x)$.&lt;/p&gt;

&lt;p&gt;$$u(y) - \int_{\Omega}  f(x)K(y, x)dx = \sum_{\beta} \int_{\partial\Omega}\psi_{\beta}(x) K^{\beta}(y, x) dx$$&lt;/p&gt;

&lt;p&gt;Now come back to our previous exterior problem, if $f = 0$ in $\Omega^{c}$, then for $y\in\Omega$, here $\Omega$ could be internal domain or external domain.&lt;/p&gt;

&lt;p&gt;$$u(y) =\sum_{|\beta|\le m - 1}\int_{\partial\Omega}\psi_{\beta}(x) K^{\beta}(y, x) dx$$&lt;/p&gt;

&lt;p&gt;In 2D, there are $C_{m+1}^2$ terms in this summation, with discretization, and merge weights into $\psi$.&lt;/p&gt;

&lt;p&gt;$$u(y_j) = \sum_{\beta} \sum_{k=1}^p \psi_{\beta}(x_k) K^{\beta}(x_k, y_j) $$&lt;/p&gt;

&lt;p&gt;There are $pC_{m+1}^2$ unknowns for this problem. Just one surface is enough. This can be seen as an extension of &lt;code&gt;KIFMM&lt;/code&gt; method.&lt;/p&gt;

&lt;h3 id=&quot;toc_0&quot;&gt;Numerical concerns&lt;/h3&gt;

&lt;p&gt;The summation over $\partial\Omega$ requires too many points (unknowns) to find out. Here we can simulate  $K^{\beta}(x_k, y_j)$ by taking finite difference to approximate the derivatives. Then we only need $m$ surfaces to find out all $K^{\beta}(x, \cdot)$, each surfaces we can place equally spaced $p$ points.&lt;/p&gt;

&lt;h3 id=&quot;toc_1&quot;&gt;Infinite order case&lt;/h3&gt;

&lt;p&gt;It seems to me that given all points inside a annulus will be enough for this.&lt;/p&gt;

&lt;h3 id=&quot;toc_2&quot;&gt;Failure for numerics&lt;/h3&gt;

&lt;p&gt;Just for a update. In numerical world, finite difference is rather a really bad idea to approximate derivatives, esp. those high order terms. Thus &lt;code&gt;KIFMM&lt;/code&gt; is an effective fast &lt;em&gt;low&lt;/em&gt; order PDE solver.&lt;/p&gt;
</description>
        <pubDate>Fri, 19 Aug 2016 00:00:00 -0500</pubDate>
        <link>http://www.ma.utexas.edu/users/yzhong/2016/08/19/thoughts-on-fast-multipole-iii/</link>
        <guid isPermaLink="true">http://www.ma.utexas.edu/users/yzhong/2016/08/19/thoughts-on-fast-multipole-iii/</guid>
      </item>
    
      <item>
        <title>Thoughts on Fast Multipole II</title>
        <description>&lt;p&gt;In last post, I sort of believe that &lt;code&gt;KIFMM&lt;/code&gt; was limited to a small portion of PDE, especially for second order elliptic equations, while the deeper idea is not the same thing at all.&lt;/p&gt;

&lt;h3 id=&quot;toc_0&quot;&gt;Equivalence of information&lt;/h3&gt;

&lt;p&gt;I realized that there is something called &lt;code&gt;Equivalence of information&lt;/code&gt; here, for example, Laplacian $\Delta u = 0$ made solution depending only information on boundary, as we called boundary value problems.  Then we can define the equivalence class of equation $P u = 0$ that associated with pseudo-differential operator $P$.&lt;/p&gt;

&lt;p&gt;In theory, even higher ordered elliptic equation&lt;/p&gt;

&lt;p&gt;$$P(x, D) u =  \sum_{|\alpha| \le 2m} c_{\alpha} D^{\alpha} u = 0$$&lt;/p&gt;

&lt;p&gt;we can see that for this equation, classical results could apply easily, and we consider the weak formulation, if vector-function $\tilde{g} = (g_{\alpha})_{|\alpha|\le m-1}$,  which satisfies
$$|\tilde{g}| = \sum_{\alpha} |g_{\alpha}| $$
is finite, we say $\tilde{g} \in W^{m-1}(\partial\Omega)$. We are looking for $u\in W^{2m}(\Omega)\cap W^{m-1}(\overline{\Omega})$ such that  $Pu = 0$ and $D^{\alpha} u|_{\partial\Omega} = g_{\alpha}$.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For any bounded domain $\Omega$, there is unique weak solution to the Dirichlet problem $P u = 0$. When boundary is smooth enough, the weak solution is also classical solution.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;On the other hand, the exterior problem also has unique solution for the same Dirichlet boundary conditions.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If $Pu = 0$, for any given measure $\nu^{\alpha}\in\Omega$, there exists $\mu^{\alpha}\in \partial\Omega$ that
$$\sum_{|\alpha|\le m-1} \int (D^{\alpha}u) d\mu^{\alpha} = \sum_{|\alpha|\le m -1} \int (D^{\alpha} u) d\nu^{\alpha}$$&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The proof should be found somewhere in &lt;code&gt;ADN (Agmon, Douglis, Nirenberg)&lt;/code&gt;, uniqueness could be concluded from something similar of Lax-Milgram. That also reveals the fact that this operator $P$ has equivalence class $\Omega\sim (\partial\Omega)^{m}$. Since we can use finite difference method to approximate $D^{\alpha} u$ on $\partial \Omega$, by giving $u$ at $\partial\Omega + t_i\mathbf{n}$ surfaces, where $t_0, \cdots, t_{m-1}\in (0,\epsilon)$. Now our problem is how to generate those surfaces/or small domains for equivalence potential.&lt;/p&gt;

&lt;h3 id=&quot;toc_1&quot;&gt;Equivalent cluster of surfaces&lt;/h3&gt;

&lt;p&gt;Define cluster of surfaces $C(t_i),i=0,\cdots, m-1$, where $C(t_i) = {x + t_i \mathbf{n}, x\in \partial\Omega}$. We also consider the solutions on each surfaces $C_i = C(t_i)$ as $u_i$.&lt;/p&gt;

&lt;p&gt;Then $D^{\alpha} u$ can be computed through finite difference. Especially, on square surface, this is quite straightforward to compute each derivatives.&lt;/p&gt;

&lt;h3 id=&quot;toc_2&quot;&gt;Exterior to Interior problem&lt;/h3&gt;

&lt;p&gt;Consider free space Green function for internal source $f$, the whole space solution is
$$u(x) = \int_{\Omega} K(x, y) f(y) dy$$
and here we are looking for $\Lambda_{\alpha}$ such that $x\in \Omega^{c}$,
$$u(x) = \sum_{|\alpha|\le m - 1} \int_{\partial\Omega} \Lambda_{\alpha}(x, y) \underline{D^{\alpha} u(y)}dy$$&lt;/p&gt;

&lt;h3 id=&quot;toc_3&quot;&gt;Interior to Exterior problem&lt;/h3&gt;

&lt;p&gt;The exterior problem will be the same, except the source $f$ lives outside of the domain $\Omega$.&lt;/p&gt;
</description>
        <pubDate>Thu, 18 Aug 2016 00:00:00 -0500</pubDate>
        <link>http://www.ma.utexas.edu/users/yzhong/2016/08/18/thoughts-on-fast-multipole-II/</link>
        <guid isPermaLink="true">http://www.ma.utexas.edu/users/yzhong/2016/08/18/thoughts-on-fast-multipole-II/</guid>
      </item>
    
      <item>
        <title>Thoughts on Fast Multipole</title>
        <description>&lt;p&gt;We are most interested in those kernel independent methods, and so far, we are aware of two mainstream methods, one is &lt;code&gt;KIFMM&lt;/code&gt;, the other is &lt;code&gt;BBFMM&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;They have very similar structure(upward pass, downward pass) of algorithm and exact the same data interaction, we call these common steps &lt;code&gt;M2M&lt;/code&gt;, &lt;code&gt;M2L&lt;/code&gt;, &lt;code&gt;L2L&lt;/code&gt;, by building a &lt;code&gt;kd-tree&lt;/code&gt;, with each leaf node containing at least $s$ particles. The brief algorithm is described as&lt;/p&gt;
&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;# build tree(partly) involves S2M, M2M two parts.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;upwardPass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;# postorder traversal&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;particles&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threshold&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# it is at leaf&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;S2M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# not leaf&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;divide&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;xrange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;upwardPass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;M2M&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;python language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;c&quot;&gt;# downPass involves M2L, L2L.&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;downPass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;c&quot;&gt;# preorder&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;isLeaf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;L2L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# U List&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;L2P&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# put current data into correct spots&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;processData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# V List&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;M2L&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;# preorder traversal&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;xrange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;downPass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;child&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The algorithm is trivial with understanding of the information flow, however, we are particular interested in the core idea.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;KIFMM&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;It bases on potential theory in harmonic analysis, or simply Green&amp;#39;s formula for second order operator like Laplacian. Second order PDE always has unique solution for exterior and interior boundary value problem, which means, the kernel must obey harmonic property, inside information must be equivalent(can transform to each other) to information on surface.&lt;/p&gt;

&lt;p&gt;This makes the algorithm very effective if the kernel is fundmental solution of second order PDE, because, using a few points on surface will total be equivalent to all nodes inside the grid.&lt;/p&gt;

&lt;p&gt;However, the limitation is also obvious, it can only work under the second order PDE, because the equation must have the potential property, that outside information can be calculated through following boundary integral, since the source is inside $\Omega$, it is a homogeneous exterior boundary value problem, solution should be something like&lt;/p&gt;

&lt;p&gt;$$u(x) = \int_{\partial\Omega} K(x, y) \psi(y)$$&lt;/p&gt;

&lt;p&gt;If the kernel does not fit the potential theory framework, this method does not work anymore, surface/boundary value cannot be used for the evaluation of the solution merely.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;BBFMM&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This is method is something general, but requires more time on solution for special problems, since interpolation methods always need redundant interior data, this method actually is doing expansion of the kernel into small decoupling products.&lt;/p&gt;

&lt;p&gt;$$K(x, y) \sim \sum_{k=1}^N c_k S_k(x)T_k(y)$$&lt;/p&gt;

&lt;p&gt;Currently, there are some polynomial based $S_k, T_k$ such as Chebyshev and Lagrange, providing cut-off residue as higher ordered terms.&lt;/p&gt;

&lt;p&gt;We are more interested in selecting appropriate basis $S$ and $T$ such that&lt;/p&gt;

&lt;p&gt;$$\min |K(x, y) - \sum_{k=1}^N c_k S_k(x)T_k(y)|_{L^p(\Omega\times \Omega)}$$&lt;/p&gt;

&lt;p&gt;since in discretized model, this turns out to be&lt;/p&gt;

&lt;p&gt;$$\min\max_i | \sum_j K(x_i, y_j)\phi_j -\sum_{k=1}^N c_k S_k(x_i)\sum_j T_k(y_j)\phi_j| $$&lt;/p&gt;

&lt;p&gt;we observe that once the functions are found, the cost will be $\mathcal{O}(N n)$. It is quite straightforward to see Fourier transform is an example, but only good for fluctuation kernel, for smooth case, polynomial could be good approximation with good performance in accuracy. Thus if we are facing some unknown kernel or something other than second order PDE, &lt;code&gt;BBFMM&lt;/code&gt; is somewhat a first choice for the first try.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 16 Aug 2016 00:00:00 -0500</pubDate>
        <link>http://www.ma.utexas.edu/users/yzhong/2016/08/16/thoughts-on-fast-multipole/</link>
        <guid isPermaLink="true">http://www.ma.utexas.edu/users/yzhong/2016/08/16/thoughts-on-fast-multipole/</guid>
      </item>
    
  </channel>
</rss>